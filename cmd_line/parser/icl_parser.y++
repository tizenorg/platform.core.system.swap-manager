    %define api.pure
%parse-param { struct pcdata * pp }

/* ICL grammar */

%{

    #include <stdio.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <dirent.h>
    #include <limits.h>
    #include <stdlib.h>
    #include <string.h>
    #include "CConfig.h"
    #include "stddebug.h"
    #include "CInterpreter.h"
    #include "lex_mem.h"
    #include "da_protocol.h"

    #include "CCommonContainer.h"
    #include "CClient.h"
    #include "CProbeFBI.h"
    #include "CProbeDataFBIVar.h"

    #define YYERROR_VERBOSE 1

    #define RISE_ERROR(msg)		\
    do					\
    {					\
	yyerror(NULL, "ERROR: " msg);	\
	if (GLOBALS->nMode != CONF_ONLY) { \
	    YYERROR;			\
	} else {			\
	    YYABORT;			\
	}				\
    } while(0)

    #define PRINT_OK			\
    if (GLOBALS->nMode != CONF_ONLY) {	\
            fprintf(YYOUT, "ok\n");	\
    }

    #define PRINT_ERROR(msg)		\
    if (GLOBALS->nMode != CONF_ONLY) {  \
            fprintf(YYOUT, "error\n");	\
	    fprintf(YYOUT, msg);	\
	    fprintf(YYOUT, "\n");	\
	    exit(1);			\
    }


    //If the number of variables is exceeded 32, tell Anatoly.


    // types of library instrumentation ( x - standart instrumentation, m - memory access instr., a - all types )
    const int INST_TYPE__X = COMMON_TRACE;
    const int INST_TYPE__E = ONLY_ENTRY_TRACE;

int yylex(void);
%}

%union
{
    unsigned long ulValue;
    struct in_addr Ip;
    char * szValue;
    char cDataType;
    int nVar;
    long slValue;
    int nValue;
    int nInstType;

    feature_code nFeatureType;

    app_type_t nAppType;
    probe_t  nProbeType;
    probe_level_type_t nProbeLevelType;
    TargetType_t nTargetType;

    CProbeFBI *fbiProbe;
    CProbeDataFBIVar *fbiVar;
    CProbeDataFBIVarList *fbiVarsList;
    CProbeDataFBIStepList *fbiStepsList;
    CProbeDataFBIStep *fbiStepElm;
}

%{
    #include "flex_common.h"

    #define YYPCDATA pp
    #define YYLEX_PARAM pp->scaninfo
    #define GLOBALS ((struct pcdata *)yyget_extra( pp->scaninfo ))
    #define GLOBAL Global
    #define YYOUT yyget_out(YYLEX_PARAM)

// FIXME: Turn these definitions into CConfig's methods
#ifdef TARGET
#define GetBinPath(profile) profile->m_ssTargetBinPath;
#define GetLibsPath(profile) profile->m_ssTLibsPath
#else
#define GetBinPath(profile) profile->m_ssHostBinPath
#define GetLibsPath(profile) profile->m_ssLibsPath
#endif

    void PrintPrompt(struct pcdata * pp)
    {
	if (1) {
		fprintf(YYOUT, "#>");
	} else {
		fprintf(YYOUT, "\n");
	}
    }

    int yyerror(struct pcdata * pp, const char * s)
    {
	if (GLOBALS->nMode != CONF_ONLY) {
		fprintf(stderr, "..");
		for (int i = 0; i < GLOBALS->_columnNum - 1; i++) {
			fprintf(stderr, ".");
		}
		fprintf(stderr, "^\n");
	}
	fprintf(stderr, "Line: #%d:%d\t\t%s\n", GLOBALS->_lineNum, GLOBALS->_columnNum, s);
	if (GLOBALS->nMode != CONF_ONLY)
	{
	    PrintPrompt(YYPCDATA);
	}
	return 0;
    }

%}

/* -------------- axiom --------------- */
%start		SCRIPT

/* -------------- tokens -------------- */

/* keywords */
/* set commands */
%token		setv
%token		setp
%token		setd

/* get commands */
%token		getv
%token		getp
%token		getall
%token		getlibs

%token		traceinfo
%token		delp
%token		lib_name

/* target */
%token		target_type
%token		target_ip
%token		target_port
%token		target_type_virtual
%token		target_type_device
%token		target_type_auto
%token		buffer_size
%token		buffer_cont

/**/
%token		cur_app
%token		cur_lib
%token		step
%token		var
%token		feature

/* probe types */
%token		kern
%token		app
%token		lib

/* probe subtype */
%token		fbi

/* param types */
%token		sdec32
%token		uhex32
%token		_float
%token		_char
%token		str

%token		all
%token		_start
%token		apply_config
%token		stop
%token		ignore
%token		clear
%token		save
%token		savepf
%token		loadpf
%token		_TRUE
%token		_FALSE
%token		x
%token		e
%token		shell
%token		parse
%token		quit
%token		__exit
%token          db_fname
%token		sampler_timer

/* application types */
%token		tizen
%token		native
%token		running
%token		common
%token		web

/* dec numbers  */
%token<ulValue>		LEX_DEC_NUM

/* hex numbers */
%token<ulValue>		LEX_HEX_NUM

/* path */
%token<szValue>		LEX_SYMNAME

/* ip address */
%token<Ip>		LEX_IP

/* memory size */
%token<ulValue>		LEX_MEM_SIZE

/* identifier */
%token<szValue>		LEX_ID

/* = */
%token			LEX_EQ

/* - */
%token			LEX_MINUS

/* commentary */
%token			LEX_COMMENT

/* new line */
%token			LEX_NEW_LINE

/* bad lexeme */
%token			LEX_BAD_LEXEME

/* feature codes */
%token		enable
%token		disable

%token		__FL_FUNCTION_PROFILING
%token		__FL_MEMORY_ALLOC_PROBING
%token		__FL_FILE_API_PROBING
%token		__FL_THREAD_API_PROBING
%token		__FL_OSP_UI_API_PROBING
%token		__FL_SCREENSHOT
%token		__FL_USER_EVENT
%token		__FL_RECORDING
%token		__FL_SYSTCALL_FILE
%token		__FL_SYSTCALL_IPC
%token		__FL_SYSTCALL_PROCESS
%token		__FL_SYSTCALL_SIGNAL
%token		__FL_SYSTCALL_NETWORK
%token		__FL_SYSTCALL_DESC
%token		__FL_CONTEXT_SWITCH
%token		__FL_NETWORK_API_PROBING
%token		__FL_OPENGL_API_PROBING
%token		__FL_FUNCTION_SAMPLING
%token		__FL_MEMORY_ALLOC_ALWAYS_PROBING
%token		__FL_FILE_API_ALWAYS_PROBING
%token		__FL_THREAD_API_ALWAYS_PROBING
%token		__FL_OSP_UI_API_ALWAYS_PROBING
%token		__FL_NETWORK_API_ALWAYS_PROBING
%token		__FL_OPENGL_API_ALWAYS_PROBING
%token		__FL_SYSTEM_CPU
%token		__FL_SYSTEM_MEMORY
%token		__FL_SYSTEM_PROCESS
%token		__FL_SYSTEM_THREAD_LOAD
%token		__FL_SYSTEM_PROCESSES_LOAD
%token		__FL_SYSTEM_DISK
%token		__FL_SYSTEM_NETWORK
%token		__FL_SYSTEM_DEVICE
%token		__FL_SYSTEM_ENERGY
%token		__FL_WEB_PROFILING











%token LEX_BRACE_OPEN
%token LEX_BRACE_CLOSE
%token LEX_LIST_DELIMETER





/* -------------- some nonterminals -------------- */
%type<nAppType>	APP_TYPE
%type<nProbeLevelType>	PROBE_TYPE
%type<nProbeType>	PROBE_SUBTYPE

%type<cDataType>	DATA_TYPE
%type<nVar>		VAR_NAME
%type<slValue>		OFFSET
%type<slValue>		POINTER_ORDER
%type<szValue>		TRACE_BIN_FILE
%type<szValue>		PROFILE

%type<nFeatureType>	FEATURE_VALUE

%type<fbiProbe>		FBI_PROBE

%type<fbiVar>		FBI_VAR
%type<fbiVarsList>	FBI_VARS_LIST
%type<fbiVarsList>	FBI_VAR_LIST_ELM


%type<fbiStepElm>	FBI_STEP
%type<fbiStepsList>	FBI_STEPS_LIST_ELM
%type<fbiStepsList>	FBI_STEPS_LIST

%type<nTargetType>	TARGET_TYPE


%%

/* production */

SCRIPT
	: /* empty */
	| SCRIPT LINE
	;

LINE
	: COMMAND LEX_NEW_LINE
	| LEX_COMMENT LEX_NEW_LINE
	| LEX_NEW_LINE
	{
	    if (GLOBALS->nMode != CONF_ONLY) {
		PrintPrompt(YYPCDATA);
	    }
	}
	| error LEX_NEW_LINE
	{
	    yyerrok;
	    if (GLOBALS->nMode == CONF_ONLY) {
		YYABORT;
	    }
	}
	;


COMMAND:	CONF_COMMAND
		{
			if (GLOBALS->nMode != CONF_ONLY) {
				PrintPrompt(YYPCDATA);
			}
		} |
		ACT_COMMAND
		{
			if (GLOBALS->nMode != CONF_ONLY) {
				PrintPrompt(YYPCDATA);
			}
		}
		;

CONF_COMMAND:
		setv target_ip LEX_IP		{
			TRACE("setv target_ip 'IP' %d", $3 );
			GLOBAL->getConfig()->setTargetIP($3);
		} |

		setv target_port LEX_DEC_NUM	{
			TRACE("setv target_port '%lu'", $3);
			GLOBAL->getConfig()->setTargetPort($3);
		} |

		setv target_type TARGET_TYPE	{
			TRACE("setv target_type '%d'", $3);
			GLOBAL->getConfig()->setTargetType($3);
		} |

		setv target_port LEX_DEC_NUM	{
			TRACE("setv target_port '%lu'", $3);
		} |

		setv cur_app APP_TYPE LEX_SYMNAME LEX_SYMNAME
		{
			TRACE("setv cur_app %d '%s' '%s'", $3, $4, $5);
			GLOBAL->getConfig()->setCurrentApplication(static_cast<app_type_t>$3, $4, $5);
		}|

		setv cur_lib LEX_SYMNAME
		{
			TRACE("setv cur_lib '%s'", $3);
			GLOBAL->getConfig()->setCurrentLib($3);
		} |

		setv feature enable FEATURE_VALUE {
			TRACE("setv feature enable '%lx'", $4);
			GLOBAL->getConfig()->setFeature($4, true);
		} |
		setv feature disable FEATURE_VALUE {
			TRACE("setv feature disable '%lx'", $4);
			GLOBAL->getConfig()->setFeature($4, false);
		}
		;

TARGET_TYPE:	target_type_device	{ $$ = TT_DEVICE;		}|
		target_type_virtual	{ $$ = TT_VIRTUAL;		}|
		target_type_auto	{ $$ = TT_AUTO;			};

VAR_NAME:	
		lib_name		{ $$ = VAR__LIB_NAME;		} |
		target_port		{ $$ = VAR__TARGET_PORT;	} |
		buffer_size		{ $$ = VAR__BUFFER_SIZE;	} |
		buffer_cont		{ $$ = VAR__BUFFER_CONT;	} |
		;

expr: LEX_DEC_NUM  {PRINT_OK};
array_expr: array_expr expr | expr;
array: '{'array_expr'}';

CONF_COMMAND:	


		setp lib PROBE_SUBTYPE LEX_HEX_NUM  {
			GLOBAL->getConfig()->setCurrentLibProbe($4, static_cast<probe_t>($3));
		} |


		setp PROBE_TYPE fbi LEX_HEX_NUM {
			if (GLOBAL->getConfig()->setCurrentProbe($2, $4, PROBE_TYPE_FBI) != 0) {
				PRINT_ERROR("Cannot set probe");
			}
		} |
		setp PROBE_TYPE fbi LEX_HEX_NUM FBI_VARS_LIST {
			TRACE("!!!!!!!!!!!!!!!!!!!setp fbi 1 = 0x%lx:%p", $4, $5);
			if (GLOBAL->getConfig()->setCurrentProbe($2, $4, PROBE_TYPE_FBI, $5) != 0) {
				PRINT_ERROR("Cannot set probe1");
				delete $5;
			}
		} |
		setd PROBE_TYPE fbi var LEX_DEC_NUM OFFSET LEX_DEC_NUM LEX_DEC_NUM {
			TRACE("!!!!!!!!!!!!!!!!!!!setp fbi var = %lu %li %lu %lu", $5, $6, $7, $8);
			CProbeDataFBIVar *FBIvar = new CProbeDataFBIVar($5, $6, $7, $8);
			if (GLOBAL->getConfig()->addCurrentProbeData($2, FBIvar) != 0) {
				PRINT_ERROR("Cannot add var");
				delete FBIvar;
			}
		} |
		setd PROBE_TYPE fbi step POINTER_ORDER OFFSET {
			TRACE("!!!!!!!!!!!!!!!!!!!setp fbi step = %li %li", $5, $6);
			CProbeDataFBIStep *FBIStep = new CProbeDataFBIStep($5, $6);
			if (GLOBAL->getConfig()->addCurrentProbeData($2, FBIStep) != 0) {
				PRINT_ERROR("Cannot add step");
				delete FBIStep;
			}
		} |
		;

LIST_DELIMETER:		LEX_LIST_DELIMETER | LEX_LIST_DELIMETER LEX_NEW_LINE;
BRACE_OPEN:		LEX_BRACE_OPEN | LEX_BRACE_OPEN LEX_NEW_LINE;
BRACE_CLOSE:		LEX_BRACE_CLOSE | LEX_BRACE_CLOSE LEX_NEW_LINE;


FBI_PROBE:		LEX_HEX_NUM FBI_VARS_LIST {
			};

FBI_VARS_LIST:		BRACE_OPEN FBI_VAR_LIST_ELM BRACE_CLOSE {
				$$ = $2;
				TRACE("????????? 1 %p -> %p", $2, $$);
				$2->printList();
			};

FBI_VAR_LIST_ELM:	BRACE_OPEN FBI_VAR BRACE_CLOSE {
				$$ = new CProbeDataFBIVarList();
				TRACE("????????? 2 %p -> %p", $2, $$);
				$$->addData($2);
			} |
			BRACE_OPEN FBI_VAR BRACE_CLOSE LIST_DELIMETER FBI_VAR_LIST_ELM {
				$$ = $5;//new FBIStepElm();
				$$->addData($2);
				TRACE("????????? setp step list add %p -> %p ", $2, $5);
			};



FBI_VAR:			LEX_DEC_NUM LIST_DELIMETER OFFSET LIST_DELIMETER LEX_DEC_NUM LIST_DELIMETER LEX_DEC_NUM LIST_DELIMETER FBI_STEPS_LIST
			{
				/* var id (8b), register offset (8b), register num (1b), data size (4b)*/
				TRACE("id=%lu off=%lu reg=%lu size=%lu list=%p", $1, $3, $5, $7, $9);
				$$ = new CProbeDataFBIVar($1, $3, $5, $7);
				$$->setData($9);
				$$->printList();
			};

FBI_STEPS_LIST:		BRACE_OPEN FBI_STEPS_LIST_ELM BRACE_CLOSE {
				TRACE("!!!!!!!!!!!!!!!!!!!setp fbi 3 %p", $2);
				$$ = $2;
			};

FBI_STEPS_LIST_ELM:	BRACE_OPEN FBI_STEP BRACE_CLOSE {
				$$ = new CProbeDataFBIStepList();
				TRACE("!!!!!!!!!!!!!!!!!!! step list start %p->%p", $2, $$);
				$$->addData($2);
			}|
			BRACE_OPEN FBI_STEP BRACE_CLOSE LIST_DELIMETER FBI_STEPS_LIST_ELM {
				$$ = $5;//new FBIStepElm();
				$$->addData($2);
				TRACE("!!!!!!!!!!!!!!!!!!!  setp step list add %p -> %p ", $2, $5);
			};

FBI_STEP:		POINTER_ORDER LIST_DELIMETER OFFSET {
				//FBIStepElm *elm = new FBIStepElm(new FBIStep($1,$3));
				CProbeDataFBIStep *FBIStep = new CProbeDataFBIStep($1, $3);
				$$ = FBIStep;
				TRACE("step %p: ord=%lu off=0x%lx", $$, $1, $3)
			};

PROBE_TYPE:	kern	{ $$ = PROBE_TYPE_LEVEL_KERNEL; } |
		app	{ $$ = PROBE_TYPE_LEVEL_APP;    } |
		lib	{ $$ = PROBE_TYPE_LEVEL_LIB;    };

PROBE_SUBTYPE:	fbi	{ $$ = PROBE_TYPE_FBI;     }

APP_TYPE:	native	{ $$ = APP_TYPE_TIZEN;  } |
		running	{ $$ = APP_TYPE_RUNNING; } |
		common	{ $$ = APP_TYPE_COMMON;  } |
		web	{ $$ = APP_TYPE_WEB;     }
		;


DATA_TYPE:	sdec32	{ $$ = 'd'; } |
		uhex32	{ $$ = 'x'; } |
		_float	{ $$ = 'f'; } |
		_char	{ $$ = 'c'; } |
		str	{ $$ = 's'; }
		;

POINTER_ORDER:	LEX_DEC_NUM | LEX_HEX_NUM { $$ = static_cast<long>($1);   };
OFFSET:		LEX_MINUS LEX_HEX_NUM	{ TRACE("->hex=%p", $2); $$ = 0 - static_cast<long>($2); } |
		LEX_HEX_NUM		{ $$ = static_cast<long>($1);   }
		;

FEATURE_VALUE:
		__FL_FUNCTION_PROFILING           { $$ = FL_FUNCTION_PROFILING           ;/*# On/Off the UserSpaceInst */} |
		__FL_MEMORY_ALLOC_PROBING         { $$ = FL_MEMORY_ALLOC_PROBING         ;/*# memory allocation API (glibc) */} |
		__FL_FILE_API_PROBING             { $$ = FL_FILE_API_PROBING             ;/*# file API (glibc, OSP) */} |
		__FL_THREAD_API_PROBING           { $$ = FL_THREAD_API_PROBING           ;/*# thread API (glibc, OSP) */} |
		__FL_OSP_UI_API_PROBING           { $$ = FL_OSP_UI_API_PROBING           ;/*# UI API (OSP) */} |
		__FL_SCREENSHOT                   { $$ = FL_SCREENSHOT                   ;/*# Screenshot */} |
		__FL_USER_EVENT                   { $$ = FL_USER_EVENT                   ;/*# events of Touch, Gesture, Orientation, Key */} |
		__FL_RECORDING                    { $$ = FL_RECORDING                    ;/*# recording the user event */} |
		__FL_SYSTCALL_FILE                { $$ = FL_SYSTCALL_FILE                ;/*# File operation syscalls tracing */} |
		__FL_SYSTCALL_IPC                 { $$ = FL_SYSTCALL_IPC                 ;/*# IPC syscall tracing */} |
		__FL_SYSTCALL_PROCESS             { $$ = FL_SYSTCALL_PROCESS             ;/*# Process syscalls tracing */} |
		__FL_SYSTCALL_SIGNAL              { $$ = FL_SYSTCALL_SIGNAL              ;/*# Signal syscalls tracing */} |
		__FL_SYSTCALL_NETWORK             { $$ = FL_SYSTCALL_NETWORK             ;/*# Network syscalls tracing */} |
		__FL_SYSTCALL_DESC                { $$ = FL_SYSTCALL_DESC                ;/*# Descriptor syscalls tracing */} |
		__FL_CONTEXT_SWITCH               { $$ = FL_CONTEXT_SWITCH               ;/*# Context switch tracing */} |
		__FL_NETWORK_API_PROBING          { $$ = FL_NETWORK_API_PROBING          ;/*# network API (glibc, OSP, libsoap, openssl) */} |
		__FL_OPENGL_API_PROBING           { $$ = FL_OPENGL_API_PROBING           ;/*# openGL API */} |
		__FL_FUNCTION_SAMPLING            { $$ = FL_FUNCTION_SAMPLING            ;/*# Function sampling */} |
		__FL_MEMORY_ALLOC_ALWAYS_PROBING  { $$ = FL_MEMORY_ALLOC_ALWAYS_PROBING  ;/*# memory allocation API (glibc) always */} |
		__FL_FILE_API_ALWAYS_PROBING      { $$ = FL_FILE_API_ALWAYS_PROBING      ;/*# file API (glibc, OSP) always */} |
		__FL_THREAD_API_ALWAYS_PROBING    { $$ = FL_THREAD_API_ALWAYS_PROBING    ;/*# thread API (glibc, OSP) always */} |
		__FL_OSP_UI_API_ALWAYS_PROBING    { $$ = FL_OSP_UI_API_ALWAYS_PROBING    ;/*# UI API (OSP) always */} |
		__FL_NETWORK_API_ALWAYS_PROBING   { $$ = FL_NETWORK_API_ALWAYS_PROBING   ;/*# network API (glibc, OSP, libsoap, openssl) always */} |
		__FL_OPENGL_API_ALWAYS_PROBING    { $$ = FL_OPENGL_API_ALWAYS_PROBING    ;/*# openGL API always */} |
		__FL_SYSTEM_CPU                   { $$ = FL_SYSTEM_CPU                   ;/*# CPU core load, frequency */} |
		__FL_SYSTEM_MEMORY                { $$ = FL_SYSTEM_MEMORY                ;/*# */} |
		__FL_SYSTEM_PROCESS               { $$ = FL_SYSTEM_PROCESS               ;/*# Process load */} |
		__FL_SYSTEM_THREAD_LOAD           { $$ = FL_SYSTEM_THREAD_LOAD           ;/*# */} |
		__FL_SYSTEM_PROCESSES_LOAD        { $$ = FL_SYSTEM_PROCESSES_LOAD        ;/*# Process size(VSS, PSS. RSS), heap usage(application, library), physical memory in use */} |
		__FL_SYSTEM_DISK                  { $$ = FL_SYSTEM_DISK                  ;/*# */} |
		__FL_SYSTEM_NETWORK               { $$ = FL_SYSTEM_NETWORK               ;/*# */} |
		__FL_SYSTEM_DEVICE                { $$ = FL_SYSTEM_DEVICE                ;/*# */} |
		__FL_SYSTEM_ENERGY                { $$ = FL_SYSTEM_ENERGY                ;/*# */} |
		__FL_WEB_PROFILING                { $$ = FL_WEB_PROFILING                ;/*# */}
		;


ACT_COMMAND:	getall				{GLOBAL->getConfig()->getAll();} |
		getv all			{} |
		getv VAR_NAME			{} |
		getp all			{} |
		getp kern			{} |
		getp lib LEX_SYMNAME		{} |
		getp app			{} |
		getp PROBE_TYPE	all		{} |
		getp PROBE_TYPE LEX_HEX_NUM	{} |
		shell				{
							if (GLOBALS->nMode == CONF_ONLY)
							{
								RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
							}
							else
							{
								fprintf( YYOUT, "%s\n", MSG_START_SHELL );
								system(CMD_PATH_TO_SHELL);
								fprintf( YYOUT, "%s\n", MSG_EXIT_SHELL );
							}
						} |
		shell LEX_SYMNAME	{
							char * szShellCmd = $2;
							TRACE("shell '%s'", szShellCmd);
							if (GLOBALS->nMode == CONF_ONLY)
							{
								DELETE_LEX_STR(szShellCmd);
								RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
							}
							else
							{
								system(szShellCmd);
								DELETE_LEX_STR(szShellCmd);
							}
						}
						;

ACT_COMMAND:	delp all			{ /* del all probes*/
						} |
		delp PROBE_TYPE all		{ /* del all probes by type */
							PRINT_OK;
						} |
		delp PROBE_TYPE LEX_HEX_NUM	{ /* del probe by addr */
							PRINT_OK;
						}
		;

ACT_COMMAND:	traceinfo                    {
                                                if (GLOBALS->nMode == CONF_ONLY)
                                                {
                                                        //RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
                                                }
                                                else
                                                {
#if defined(ACTIVE_CMDS_ENABLED)
                                                        unsigned long pnArray[BSECI_COUNT];
                                                        GLOBAL->getControlAPI()->ControlAPIGetBufferStatus(pnArray, BSECI_COUNT);
							// In any state except EC_STATE_IDLE the count of events must be greater than 0
							if ( pnArray[BSECI_STATE] != EC_STATE_IDLE && pnArray[BSECI_SAVED] == 0) {
								PRINT_ERROR("Reboot system");
							} else if ( pnArray[BSECI_STATE] == EC_STATE_IDLE && pnArray[BSECI_SAVED] == 0) {
								PRINT_OK;
								printf("Trace collection not started\n");
							} else {
								PRINT_OK;
								printf("buffer_size: %ld \n", pnArray[BSECI_BUFFER_SIZE] );
								printf("first: %ld \n", pnArray[BSECI_FIRST] );
								printf("after_last: %ld \n", pnArray[BSECI_AFTER_LAST]);
								printf("collision_count: %ld \n", pnArray[BSECI_COLLISION]);
								printf("lost_events_count: %ld \n", pnArray[BSECI_LOST]);
								printf("trace_size: %ld \n", pnArray[BSECI_TRACE_SIZE]);
								printf("ignored_events_count: %ld \n", pnArray[BSECI_IGNORED] );
								printf("discarded_events_count: %ld \n", pnArray[BSECI_DISCARDED] );
								printf("saved_events_count: %ld \n", pnArray[BSECI_SAVED] );
							}

#endif // defined(ACTIVE_CMDS_ENABLED)
                                                }
                                        } |


ACT_COMMAND
	: _start
	{
	    TRACE("start");
	    if (GLOBALS->nMode == CONF_ONLY) {
		//RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
		PRINT_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
	    } else {
//#if defined(ACTIVE_CMDS_ENABLED)
//		TRACE("ControlAPISetConfig(NULL, GLOBAL->getConfig())");
//		GLOBAL->getControlAPI()->ControlAPISetConfig(NULL, /*GLOBAL->getConfig()*/);
		if (GLOBAL->getControlAPI()->startTrace() != 0) {
		    TRACE("Error while start data collection!");
		    PRINT_ERROR(MSG_CANT_START_DATA_COLLECTION);
		} else {
		    PRINT_OK;
		}
//#endif // defined(ACTIVE_CMDS_ENABLED)
	    }
	}
	| stop
	{
	    if (GLOBALS->nMode == CONF_ONLY) {
		//RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
	    } else {
#if defined(ACTIVE_CMDS_ENABLED)
		GLOBAL->getControlAPI()->ControlAPIStopTrace();
		PRINT_OK;
#endif // defined(ACTIVE_CMDS_ENABLED)
	    }
	}
	| clear
	{
	    if (GLOBALS->nMode == CONF_ONLY) {
		RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
	    } else {
		// ControlAPIClearTrace();
	    }
	}
	| save TRACE_BIN_FILE
	{
	    char *szName = $2;
	    int iLength = strlen("cp -f  ") + strlen(szName) +
		strlen(DEFAULT_DB_FILE) + strlen(szName) + 1;
	    char *szCmd = new char[iLength];
	    snprintf(szCmd, iLength, "cp -f %s %s", DEFAULT_DB_FILE, szName);
	    system(szCmd);
	    PRINT_OK;
	    printf("%s\n", szCmd);
	    delete szCmd;
	    DELETE_LEX_STR($2);
	}
	| apply_config
	{
		GLOBAL->getControlAPI()->applyConfig();
	}
;

TRACE_BIN_FILE:	LEX_SYMNAME { $$ = $1; }
		;

ACT_COMMAND:	savepf PROFILE	{
					if (GLOBALS->nMode == CONF_ONLY)
					{
					    DELETE_LEX_STR($2);
					    RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
					}
					else
					{
					    FILE * fdConfig = fopen($2, "w");
					    //PrintConfig(fdConfig, GLOBAL->getConfig());
					    fclose(fdConfig);
					    PRINT_OK;
					}
					DELETE_LEX_STR($2);
				} |
		loadpf PROFILE	{
					char * szScriptFileName = $2;
					if (GLOBALS->nMode == CONF_ONLY)
					{
					    DELETE_LEX_STR(szScriptFileName);
					    RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
					}
					else
					{
					    /* reentrant parser invocation */
					    FILE * pFdScriptFile = fopen(szScriptFileName, "r");
					    int res;
					    if (pFdScriptFile) {
						pCConfig config = GLOBAL->getConfig();
						pCControlAPI control = GLOBAL->getControlAPI();
						config->clean();

						res = YYmain(pFdScriptFile, YYOUT, CONF_ONLY);
						fclose(pFdScriptFile);
						if(!res) {
						    PRINT_OK;
						} else {
						    PRINT_ERROR("Config loaded with errors");
						}
					    } else {
						PRINT_ERROR("File not found");
					    }
					}
					DELETE_LEX_STR(szScriptFileName);
				}
				;

ACT_COMMAND:	getlibs		{
				}
				;

ACT_COMMAND:	parse		{
				}
				;

ACT_COMMAND:	quit	{
				if (GLOBALS->nMode == CONF_ONLY)
				{
					RISE_ERROR(MSG_CANT_EXECUTE_COMMAND_IN_CURRENT_MODE);
				}
				else
				{
					PRINT_OK;
					fprintf(YYOUT, "\n");
#if defined(ACTIVE_CMDS_ENABLED)
					GLOBAL->getControlAPI()->ControlAPIStopTrace();
#endif
				YYABORT;
				}
			} |
		__exit	{ exit(0); };

PROFILE:	LEX_SYMNAME { $$ = $1; }
		;

%%

int YYmain(FILE * pFd_in, FILE * pFd_out, EMode nMode)
{
	struct pcdata _perScannerData = { (EMode)0, 1, 0, NULL };

	int res = yylex_init_extra(&_perScannerData, &_perScannerData.scaninfo);
	ASSERT(res == 0);

	_perScannerData.nMode = nMode;
	yyset_in(pFd_in, _perScannerData.scaninfo);
	yyset_out(pFd_out, _perScannerData.scaninfo);
	setvbuf(pFd_out, NULL, _IOLBF, 0);

	//YYLEX;
	if (nMode != CONF_ONLY) {
		PrintPrompt(&_perScannerData);
	}

	res = yyparse(&_perScannerData);

	return res;
}

